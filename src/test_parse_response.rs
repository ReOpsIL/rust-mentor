
#[cfg(test)]
mod tests {
    use crate::app::LearningModule;
    use crate::data::Topic;
    use crate::llm::{LlmClient, RawLearningModule};
    use anyhow::Result;

    #[test]
    fn test_parse_response() -> Result<()> {
        // Create a test response string similar to the one in the issue description
        let response = r#"```json
{
  "explanation": "As a Solid Intermediate Rust programmer, you're familiar with `#[test]`. Now, let's master how Cargo structures and runs tests for robust projects.\n\nRust and Cargo distinguish between two primary types of tests: **unit tests** and **integration tests**.\n\n**Unit Tests:**\n- **Location:** Reside in the `src` directory, typically within a `mod tests { ... }` module inside the file they are testing (e.g., `src/lib.rs` or `src/my_module.rs`).\n- **Annotation:** The module is marked with `#[cfg(test)]`. This is a conditional compilation attribute that tells `rustc` to only compile and include this module when running `cargo test`, not during a normal `cargo build`.\n- **Purpose:** To test a small, isolated piece of code (a 'unit'), like a single function or a method.\n- **Key Advantage:** Because they are inside the same file/crate, unit tests can access private items (functions, modules, etc.) of their parent module. This is crucial for testing internal implementation details.\n\n**Integration Tests:**\n- **Location:** Each file in the `tests` directory at the root of your project (alongside `src`) is compiled as a separate, individual crate.\n- **Convention:** This directory is a special convention recognized by Cargo. You don't need to add `#[cfg(test)]` to the files in it.\n- **Purpose:** To test your library's public API as an external user would. They test how different parts of your library work together.\n- **Key Limitation:** As separate crates, integration tests can *only* access your library's `pub` items, just like any other external crate. They cannot see private functions or modules. This enforces testing against the public contract of your code.\n\n**Shared Code in Integration Tests:**\nIf you have multiple integration test files in `tests/` and need to share setup code or helpers, create a `tests/common/mod.rs`. This file is *not* treated as an integration test crate itself but can be used as a module by other test files (e.g., `mod common;`).\n\n**Running Tests with Cargo:**\n- `cargo test`: Runs all unit, integration, and documentation tests.\n- `cargo test my_test_name`: Runs only tests whose names contain `my_test_name`.\n- `cargo test --test integration_test_filename`: Runs only the tests in the specified integration test file.\n- `cargo test -- --ignored`: Runs tests marked with the `#[ignore]` attribute.\n- `should_panic`: Use `#[should_panic]` to assert that a test function panics as expected. You can even check for a specific panic message with `#[should_panic(expected = \"panic message\")]`.\n\nThis structured approach helps maintain a clean separation between testing internal logic and public contracts, leading to more maintainable and reliable Rust projects.",
  "code_snippets": [
    "// Snippet 1: Unit tests inside a library crate.\n// This entire block of code would live in `src/lib.rs`.\n\n/// This module provides functionality for creating personalized greetings.\n\n/// Adds a prefix to the given name. This is part of the public API.\n///\n/// # Examples\n///\n/// ```\n/// // This is a doctest, which `cargo test` also runs!\n/// let greeting = my_library::add_prefix(\"World\");\n/// assert_eq!(greeting, \"Hello, World!\");\n/// ```\npub fn add_prefix(name: &str) -> String {\n    let prefix = generate_prefix(); // Uses a private helper function\n    format!(\"{}, {}!\", prefix, name)\n}\n\n/// Generates a standard prefix. This is a private implementation detail.\nfn generate_prefix() -> &'static str {\n    \"Hello\"\n}\n\n// This module will only be compiled when running `cargo test`.\n#[cfg(test)]\nmod tests {\n    // Import everything from the outer scope (the library crate)\n    use super::*;\n\n    #[test]\n    fn test_add_prefix_public_api() {\n        // Test the public function\n        assert_eq!(add_prefix(\"Rustacean\"), \"Hello, Rustacean!\");\n    }\n\n    #[test]\n    fn test_generate_prefix_private_fn() {\n        // Unit tests can access private functions of their parent module.\n        // This is a key difference from integration tests.\n        assert_eq!(generate_prefix(), \"Hello\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Name cannot be empty\")]\n    fn test_panics_on_empty_name() {\n        // A hypothetical function that should panic on invalid input.\n        fn process_name(name: &str) {\n            if name.is_empty() {\n                panic!(\"Name cannot be empty\");\n            }\n            // ...\n        }\n        process_name(\"\");\n    }\n}",
    "// Snippet 2: Integration tests with shared helper modules.\n// This example demonstrates a project with both a library and an integration test.\n//\n// Project Structure:\n// .\n// ├── Cargo.toml\n// ├── src\n// │   └── lib.rs\n// └── tests\n//     ├── common\n//     │   └── mod.rs\n//     └── main_integration_test.rs\n\n// --- File: src/lib.rs ---\n// This is our library crate. We assume its name in Cargo.toml is `my_loud_lib`.\npub mod utils {\n    /// A public function. Integration tests can call this.\n    pub fn make_loud(s: &str) -> String {\n        format!(\"{}!!!\", s.to_uppercase())\n    }\n\n    /// A private function. Integration tests CANNOT call this.\n    #[allow(dead_code)]\n    fn get_volume() -> u8 {\n        11\n    }\n}\n\n// --- File: tests/common/mod.rs ---\n// This module is NOT an integration test. It's a helper module\n// for other tests in the `tests/` directory.\npub fn setup() -> String {\n    // Imagine some complex setup logic here, like creating temp files or a database.\n    println!(\"\\n(Setting up common test resources...)\");\n    \"shared_data\".to_string()\n}\n\n// --- File: tests/main_integration_test.rs ---\n// This is a separate crate that depends on our library.\n// It will be compiled and run by `cargo test`.\n\n// We can use helper modules from the same directory.\nmod common;\n\n// We must import our library crate to use its public API.\n// The library's name is determined by your Cargo.toml package name.\nuse my_loud_lib::utils;\n\n#[test]\nfn test_public_api_from_integration_test() {\n    // Use the setup function from our common module.\n    let shared = common::setup();\n    assert_eq!(shared, \"shared_data\");\n\n    // Call the public function from our library.\n    let result = utils::make_loud(\"hello\");\n    assert_eq!(result, \"HELLO!!!\");\n\n    // The following line would fail to compile because `get_volume` is private:\n    // let volume = utils::get_volume();\n    // error[E0425]: cannot find function `get_volume` in module `utils`\n}"
  ],
  "exercises": [
    "You have been given a single Rust file containing a simple 'config' parser. The file contains both the logic and the tests. Your task is to refactor this into a proper Cargo library crate structure.\n\n**Initial Monolithic File:**\n```rust\n// In Cargo.toml, the library name is `config_parser`.\npub struct Config {\n    pub setting: String,\n}\n\nimpl Config {\n    pub fn new(value: &str) -> Result<Config, &'static str> {\n        if value.is_empty() {\n            return Err(\"Setting cannot be empty\");\n        }\n        let parsed_value = internal_parse_helper(value);\n        Ok(Config { setting: parsed_value })\n    }\n}\n\n// A private helper function.\nfn internal_parse_helper(raw: &str) -> String {\n    format!(\"parsed:{}\", raw)\n}\n\n// Tests are currently in the same file.\n#[test]\nfn test_internal_helper() {\n    assert_eq!(internal_parse_helper(\"data\"), \"parsed:data\");\n}\n\n#[test]\nfn test_config_creation_succeeds() {\n    let config = Config::new(\"my_value\").unwrap();\n    assert_eq!(config.setting, \"parsed:my_value\");\n}\n\n#[test]\n#[should_panic]\nfn test_config_creation_fails() {\n    Config::new(\"\").unwrap();\n}\n```\n\n**Your Tasks:**\n1.  Create a new library project: `cargo new config_parser --lib`.\n2.  Move the `Config` struct and its implementation into `src/lib.rs`. Ensure `internal_parse_helper` remains private.\n3.  Create a `mod tests` module inside `src/lib.rs` for unit tests. Move `test_internal_helper` into this module. Explain (in a comment) why this test belongs here.\n4.  Create an integration test file in the `tests/` directory named `config_tests.rs`. Move `test_config_creation_succeeds` and `test_config_creation_fails` into it. Explain (in a comment) why these tests belong here.\n5.  Ensure `cargo test` runs and passes successfully.",
    "You are working on a data processing library called `data_cruncher`. Your task is to enhance its test suite using more advanced Cargo testing features.\n\n**Library `src/lib.rs`:**\n```rust\nuse std::fs;\nuse std::io;\nuse std::path::Path;\n\npub struct DataProcessor {\n    pub data: Vec<u8>,\n}\n\nimpl DataProcessor {\n    pub fn from_file(path: &Path) -> io::Result<Self> {\n        let data = fs::read(path)?;\n        Ok(DataProcessor { data })\n    }\n\n    pub fn process(&self) -> Result<String, &'static str> {\n        if self.data.is_empty() {\n            panic!(\"Cannot process empty data!\");\n        }\n        if self.data.len() > 1000 {\n            // This is a complex, slow operation we want to skip in normal test runs.\n            std::thread::sleep(std::time::Duration::from_secs(5));\n            // ...imagine heavy computation...\n        }\n        Ok(String::from_utf8_lossy(&self.data).to_string())\n    }\n}\n```\n\n**Your Tasks:**\n1.  **Shared Setup:** In a new `tests/common/mod.rs` file, create a public function that creates a temporary test file with some string content and returns its `std::path::PathBuf`. This function should clean up after itself by deleting the file when it goes out of scope (hint: look at crates like `tempfile` or create a struct with a `Drop` implementation).\n2.  **Panic Test:** In an integration test file (`tests/processing_test.rs`), write a test that verifies `process()` panics when called on an empty `DataProcessor`. Use `#[should_panic]` to check for the specific message: `\"Cannot process empty data!\"`.\n3.  **Ignored Test:** Write an integration test that processes a large amount of data (> 1000 bytes) to test the slow path. Mark this test with the `#[ignore]` attribute. Verify that `cargo test` doesn't run it by default, but `cargo test -- --ignored` does.\n4.  **Integration Test:** Write a standard integration test that uses your setup function from `tests/common/mod.rs` to create a file, uses `DataProcessor::from_file` to read it, and then `process()` to verify the result is correct."
  ]
}
```"#;

        // Create a dummy topic
        let topic = Topic {
            topic: "Testing in Rust".to_string(),
            source: "The Rust Programming Language".to_string(),
            min_level: 0,
        };

        // Create a dummy LlmClient
        let client = LlmClient::new("dummy_api_key".to_string());

        // Call the parse_response function
        let result = client.parse_response(response.to_string(), &topic);

        // Check if parsing was successful
        match result {
            Ok(module) => {
                println!("Parsing successful!");
                println!("Topic: {}", module.topic);
                println!(
                    "Explanation (first 100 chars): {}",
                    &module.explanation[..100.min(module.explanation.len())]
                );
                println!("Number of code snippets: {}", module.code_snippets.len());
                println!("Number of exercises: {}", module.exercises.len());
                Ok(())
            }
            Err(e) => {
                println!("Parsing failed: {}", e);
                Err(e)
            }
        }
    }
}